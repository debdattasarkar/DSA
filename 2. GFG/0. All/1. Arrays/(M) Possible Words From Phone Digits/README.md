# Possible Words From Phone Digits

**Difficulty:** Medium
**Accuracy:** 52.79%
**Submissions:** 74K+
**Points:** 4
**Average Time:** 20m

---

## Problem Statement

You are given a keypad (as shown in the diagram) and an array **arr[]** containing digits, your task is to **list all possible words in any order** which can be generated by pressing numbers in arr[] sequentially.

### Note:

* Number **0** and **1** do not map to any letters.
* You can return the words in any order, the driver code will print them in sorted order.

---

### Keypad Mapping

```
1      2(ABC)  3(DEF)
4(GHI) 5(JKL)  6(MNO)
7(PQRS) 8(TUV) 9(WXYZ)
*      0       #
```

---

## Examples

### Example 1

**Input:** arr[] = [2, 3]
**Output:** [ad, ae, af, bd, be, bf, cd, ce, cf]
**Explanation:**
When we press 2 and 3 → total (3 \times 3 = 9) possible words are formed.

---

### Example 2

**Input:** arr[] = [2]
**Output:** [a, b, c]
**Explanation:**
When we press 2 → total 3 possible words formed.

---

## Constraints

* (1 \leq arr.size() \leq 9)
* (0 \leq arr[i] \leq 9)

---

## Expected Complexities

* **Time Complexity:** (O(4^n)) (since each digit maps to at most 4 letters)
* **Auxiliary Space:** (O(n)) (for recursion depth)

---

## Company Tags

* Flipkart
* Amazon
* Microsoft

---

## Topic Tags

* Arrays
* Strings
* Mathematical
* Recursion
* Backtracking
* Data Structures
* Algorithms

---

## Related Interview Experiences

* Flipkart Interview Experience Set 22 For SDE 2

---

## Related Articles

* [Find Possible Words Phone Digits]
* [Iterative Letter Combinations Of A Phone Number]

---

---

awesome — here’s an interview-ready pack: intuition, step-by-step dry run, and multiple Python solutions in your requested template (with inline comments + complexities), plus the common interview Q&A.

---

# 2) Intuition & Step-by-step dry run

## Problem recap

Given a digit array `arr` (each in `0..9`), produce **all strings** formed by pressing digits sequentially on a T9 keypad:

```
2: abc   3: def   4: ghi   5: jkl
6: mno   7: pqrs  8: tuv   9: wxyz
0,1: (no letters)
```

We append one letter per digit, in order. This is classic **cartesian product** across the letter sets — typically solved with **backtracking/DFS** or **iterative building**. Complexity is proportional to the number of outputs, i.e. up to (4^n).

## Dry run (arr = [2, 3])

* Letters: `2 -> [a,b,c]`, `3 -> [d,e,f]`
* Start with empty prefix `""`

Depth=0 (digit 2):

* take `a` → prefix `"a"`

  * next digit 3: append `d,e,f` ⇒ `"ad","ae","af"`
* take `b` → `"b"` ⇒ `"bd","be","bf"`
* take `c` → `"c"` ⇒ `"cd","ce","cf"`

Output (9): `["ad","ae","af","bd","be","bf","cd","ce","cf"]`.

---

# 3) Python solutions (interview-ready)

We’ll return results in any order (driver will sort, per prompt).

### A) Backtracking / DFS (most expected)

```python
class Solution:
    def possibleWords(self, arr):
        """
        Backtracking over the cartesian product of digit->letters.
        Time:  O(prod k_i) ~= O(4^n)   (k_i = letters per digit)
        Space: O(n) recursion + O(#answers * n) output
        """
        if not arr:
            return []

        # Mapping per T9 spec; 0 and 1 map to nothing
        phone = {
            2: "abc", 3: "def", 4: "ghi", 5: "jkl",
            6: "mno", 7: "pqrs", 8: "tuv", 9: "wxyz"
        }

        # Collect the letter sets for digits that have mappings
        letters_by_digit = []
        for d in arr:
            if d in phone:
                letters_by_digit.append(phone[d])
            else:
                # If a 0/1 appears, it contributes no letters; by common convention:
                # - If any digit has no mapping, there are ZERO words (since we need 1 char per digit)
                # If the platform instead wants to skip 0/1, uncomment the continue.
                return []  # strict interpretation
                # continue   # relaxed variant (skip digits 0/1)

        res, path = [], []

        def dfs(i):
            # If we've chosen one char for each digit, emit a word
            if i == len(letters_by_digit):
                res.append("".join(path))
                return
            # Try every letter for current digit
            for ch in letters_by_digit[i]:
                path.append(ch)
                dfs(i + 1)
                path.pop()  # backtrack

        dfs(0)
        return res
```

> If your judge expects to **skip** digits `0/1` (rather than return empty), replace the `return []` with `continue` in the mapping loop.

---

### B) Iterative breadth building (queue/product style)

```python
class Solution:
    def possibleWords(self, arr):
        """
        Iteratively build strings layer by layer (like BFS over positions).
        Time:  O(4^n)
        Space: O(4^n) for the growing frontier (plus output)
        """
        if not arr:
            return []

        phone = {
            2: "abc", 3: "def", 4: "ghi", 5: "jkl",
            6: "mno", 7: "pqrs", 8: "tuv", 9: "wxyz"
        }

        words = [""]  # start with empty prefix
        for d in arr:
            if d not in phone:
                return []  # strict; change to "continue" to skip 0/1
            next_words = []
            letters = phone[d]
            # expand the frontier with current digit's letters
            for w in words:
                for ch in letters:
                    next_words.append(w + ch)
            words = next_words

        return words
```

---

### C) Pythonic one-liner style using `itertools.product` (great to mention)

```python
from itertools import product

class Solution:
    def possibleWords(self, arr):
        """
        Cartesian product of letter lists via itertools.product.
        Time:  O(4^n)
        Space: O(4^n) for the output list
        """
        phone = {
            2: "abc", 3: "def", 4: "ghi", 5: "jkl",
            6: "mno", 7: "pqrs", 8: "tuv", 9: "wxyz"
        }

        pools = []
        for d in arr:
            if d not in phone:
                return []  # strict; change to "continue" to skip 0/1
            pools.append(phone[d])

        if not pools:
            return []

        return ["".join(tup) for tup in product(*pools)]
```

> In interviews: explain both DFS/backtracking and the `itertools.product` approach; both are acceptable, but DFS is the classic.

---

# 4) Interview Q&A (high-yield)

**Q1. What’s the complexity?**
**A.** Let each digit map to (k_i) letters (max 4). Total outputs (K = \prod k_i \le 4^n). We must generate all, so **time is Θ(K)**. Recursion depth is **O(n)** and output space is **Θ(K·n)**.

**Q2. How do you handle digits 0 and 1?**
**A. (Strict)** They map to no letters, so there are **no valid words** → return `[]`.
**A. (Relaxed)** Skip them (don’t add a position). Clarify expectation with interviewer. The prompt says “0 and 1 do not map to letters”; many platforms choose the **strict** interpretation.

**Q3. Does order matter?**
**A.** We can return in any order (driver sorts). If a deterministic order is desired, build digits left→right and letters in the mapping’s natural order.

**Q4. Why backtracking instead of nested loops?**
**A.** `n` is variable; nested loops would need `n` levels hard-coded. Backtracking scales to any `n` and prunes naturally if needed (not used here).

**Q5. How would you stream results to reduce memory?**
**A.** Yield results as a generator (replace `res.append` with `yield`); caller consumes lazily.

**Q6. How to support a custom keypad mapping (i18n)?**
**A.** Parameterize the `phone` dict; the algorithm stays the same.

**Q7. How to avoid recursion depth issues?**
**A.** Use the iterative builder (Solution B) or `itertools.product` (Solution C).

**Q8. How would you add constraints like “no vowels” or “must contain ‘ab’”?**
**A.** Add pruning during DFS: before descending or before emitting, check constraints (e.g., skip if prefix already violates rules).

---

---

perfect — here’s a **runnable, interview-style full program** for *Possible Words From Phone Digits* with:

* the requested `class Solution.possibleWords`,
* **skip 0/1** behavior (so `[8,8,1] → ['tt','tu',...,'vv']`),
* detailed inline **time/space complexity** notes,
* a tiny **driver** that prints inputs & outputs,
* and **timeit** micro-benchmarks comparing three approaches.

I’ve also added a few crisp **real-world use cases** at the end.

---

## 5) Full Python Program (with inline complexity comments + timings)

```python
"""
Possible Words From Phone Digits (T9)

Rule set used here:
- Digits 2..9 map to letters (standard T9)
- Digits 0 and 1 map to NO letters and are **SKIPPED** (do not terminate the run)
- If the array contains only 0/1, there are no words → return []

Core idea:
- Cartesian product of letter sets per mapped digit.
- We show three solutions:
  A) Backtracking/DFS (primary),
  B) Iterative frontier building,
  C) itertools.product

Global complexities (k = number of mapped digits, each maps to ≤4 letters):
- Time:  Θ(Π k_i) ≤ Θ(4^k)  (must emit every word)
- Space: O(k) for recursion/iteration depth + Θ(#answers * k) to store all words
"""

from itertools import product
import timeit
from typing import List


# ------------------------------- Primary Solution: Backtracking/DFS ------------------------------- #
class Solution:
    def possibleWords(self, arr: List[int]) -> List[str]:
        """
        Backtracking over digit→letters while **skipping 0 and 1**.

        Steps:
          1) Build `pools` list of letter strings for each mapped digit.      Time: O(n)
          2) DFS: choose one letter from pools[i] per depth i.                Time: Θ(4^k)
             - Append to `path`, recurse, backtrack.
          3) Return all built words.

        Time  : Θ(4^k)  (k = #mapped digits)
        Space : O(k) recursion + Θ(#answers * k) for the result storage
        """
        if not arr:
            return []

        phone = {
            2: "abc", 3: "def", 4: "ghi", 5: "jkl",
            6: "mno", 7: "pqrs", 8: "tuv", 9: "wxyz"
        }

        # (1) Build pools; SKIP digits 0/1  --------------------------------- O(n)
        pools: List[str] = [phone[d] for d in arr if d in phone]
        if not pools:             # only 0/1 were present
            return []

        res, path = [], []

        # (2) DFS/backtracking ---------------------------------------------- ≤ O(4^k)
        def dfs(i: int) -> None:
            if i == len(pools):                   # built one word
                res.append("".join(path))         # O(k) to join
                return
            for ch in pools[i]:                   # at most 4 choices
                path.append(ch)                   # O(1)
                dfs(i + 1)                        # recurse to next digit
                path.pop()                        # O(1) backtrack

        dfs(0)
        return res


# ------------------------------- Alternative 1: Iterative Frontier ------------------------------- #
class SolutionIterative:
    def possibleWords(self, arr: List[int]) -> List[str]:
        """
        Iteratively build the frontier (like BFS by layers).
        Time : Θ(4^k)  |  Space: Θ(4^k) for the frontier/output
        """
        phone = {
            2: "abc", 3: "def", 4: "ghi", 5: "jkl",
            6: "mno", 7: "pqrs", 8: "tuv", 9: "wxyz"
        }
        words = [""]                               # start with empty prefix
        for d in arr:
            if d not in phone:                     # skip 0/1
                continue
            letters = phone[d]
            # Cartesian expand this layer
            words = [w + ch for w in words for ch in letters]   # O(len(words)*len(letters))
        return [] if words == [""] else words


# ------------------------------- Alternative 2: itertools.product ------------------------------- #
class SolutionProduct:
    def possibleWords(self, arr: List[int]) -> List[str]:
        """
        Pythonic Cartesian product via itertools.product.
        Time : Θ(4^k)  |  Space: Θ(4^k) for returned list
        """
        phone = {
            2: "abc", 3: "def", 4: "ghi", 5: "jkl",
            6: "mno", 7: "pqrs", 8: "tuv", 9: "wxyz"
        }
        pools = [phone[d] for d in arr if d in phone]            # O(n)
        if not pools:
            return []
        return ["".join(tup) for tup in product(*pools)]          # Θ(4^k)


# -------------------------------------- Tiny timeit helper -------------------------------------- #
def bench(func, *args, number=20000):
    """
    Measure average seconds per run for func(*args) using timeit.
    For tiny inputs, Python overhead dominates; treat as relative indicator only.
    """
    total = timeit.timeit(lambda: func(*args), number=number)
    return total / number


# ------------------------------------------ Main / Demo ----------------------------------------- #
if __name__ == "__main__":
    tests = [
        # (input array, expected or note)
        ([2, 3], "9 combos like ad..cf (order may vary)"),
        ([2], "['a','b','c']"),
        ([8, 8, 1], "Expect skip 1 → 9 combos ['tt','tu','tv','ut','uu','uv','vt','vu','vv']"),
        ([0, 1, 0], "Only 0/1 → []"),
        ([7], "4 letters 'pqrs'"),
        ([9, 7, 2], "up to 4*4*3=48 words"),
    ]

    print("=== Possible Words From Phone Digits (skip 0/1) ===\n")
    sol = Solution()
    sol_it = SolutionIterative()
    sol_prod = SolutionProduct()

    for arr, note in tests:
        out_a = sol.possibleWords(arr)
        out_b = sol_it.possibleWords(arr)
        out_c = sol_prod.possibleWords(arr)
        print(f"Input: {arr}  |  Note: {note}")
        print(f"A) Backtracking output (len={len(out_a)}): {out_a}")
        print(f"B) Iterative     output (len={len(out_b)}): {out_b}")
        print(f"C) itertools     output (len={len(out_c)}): {out_c}")
        print(f"All methods agree? {sorted(out_a)==sorted(out_b)==sorted(out_c)}\n")

    # ---------------------------- Timings (average seconds per run) ---------------------------- #
    print("=== Timings (average seconds per run) ===")
    small = [8, 8, 1]         # 9 outputs
    medium = [7, 9, 8]        # 4*4*3 = 48 outputs
    big = [9, 7, 8, 6]        # 4*4*3*3 = 144 outputs (still small but illustrative)

    runs_small = 30000
    runs_medium = 8000
    runs_big = 3000

    t_a_small = bench(Solution().possibleWords, small, number=runs_small)
    t_b_small = bench(SolutionIterative().possibleWords, small, number=runs_small)
    t_c_small = bench(SolutionProduct().possibleWords, small, number=runs_small)
    print(f"Small  {small} runs={runs_small}: A {t_a_small:.8e}s | B {t_b_small:.8e}s | C {t_c_small:.8e}s")

    t_a_med = bench(Solution().possibleWords, medium, number=runs_medium)
    t_b_med = bench(SolutionIterative().possibleWords, medium, number=runs_medium)
    t_c_med = bench(SolutionProduct().possibleWords, medium, number=runs_medium)
    print(f"Medium {medium} runs={runs_medium}: A {t_a_med:.8e}s | B {t_b_med:.8e}s | C {t_c_med:.8e}s")

    t_a_big = bench(Solution().possibleWords, big, number=runs_big)
    t_b_big = bench(SolutionIterative().possibleWords, big, number=runs_big)
    t_c_big = bench(SolutionProduct().possibleWords, big, number=runs_big)
    print(f"Big    {big} runs={runs_big}: A {t_a_big:.8e}s | B {t_b_big:.8e}s | C {t_c_big:.8e}s")

    print("\nNote: numbers vary by machine and Python version.")
```

### What the program prints

* For each test, it shows the **input digits**, each method’s **output list**, and whether all methods **agree**.
* Then it prints **timeit** averages for small/medium/big inputs across all three approaches.

---

## 6) Real-World Use Cases (the important ones)

1. **T9 / Predictive Text Prototyping**
   Generate all possible letter sequences for a digit sequence as a baseline for ranking models.

2. **Phoneword Generation**
   Map phone numbers to memorable letter mnemonics for vanity numbers (e.g., 1-800-FLOWERS).

3. **Keypad-based Search UI**
   For TV remotes or car dashboards, enumerate candidate strings from numeric input to drive prefix search and autocomplete.

4. **Testing & Fuzzing**
   Produce cartesian products of small alphabets (e.g., 2–9 subsets) for stress tests of downstream pipelines.